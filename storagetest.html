<!DOCTYPE html>
<html lang="en" ng-app="testApp">
<head>
	<meta charset="UTF-8" />
	<title>Experiment: storage</title>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
	<style>

#drawdiv {
	position: absolute;
	top: 0;
	left: 0;
	right: 20%;
	bottom: 0;
}
#datadiv {
	position: absolute;
	top: 0;
	left: 80%;
	right: 0;
	bottom: 0;
	border: 1px solid green;
}

	</style>
</head>
<body ng-controller="Ctrl">
	<div id="drawdiv"">
		<canvas id="canvas">
		</canvas>
	</div>
	<div id="datadiv">
		<div>
			{{path}}
			<input type="number" ng-model="ii">
			<button ng-click="zoomInClick()">Zoom In</button>
			<button ng-click="zoomOutClick()">Zoom Out</button>
		</div>
		<div>
			<button ng-click="saveClick()">Save</button>
		</div>
	</div>	<script src="piece.js"></script>
	<script>
"use strict"
angular.module('testApp', []).controller('Ctrl', function ($scope) {

$scope.ii = 0;
$scope.path = [24, 24];

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
window.addEventListener('resize', resizeListener);
resize();

var worker = new Worker('worker.js');

var piecesToDraw = [];
var backgroundPieces = [null, null];		// up to two background pieces

var levelData = createData(-0.7436424932257446, 0.1318316199009883, 5000000, 3);
var currentLevel = levelPath($scope.path);
blah();

var draggingPiece = null;
var selectedPiece = null;

canvas.onmousedown = function (e) {
	var mouseX = e.clientX - canvas.width/2;
	var mouseY = e.clientY - canvas.height/2;
	for (var i=piecesToDraw.length; --i>=0;) {
		if (piecesToDraw[i].hitTest(mouseX, mouseY)) {
			if (selectedPiece == piecesToDraw[i]) {		// double-click
				console.log('zoom in');;;
				break;
			}
			selectedPiece = piecesToDraw[i];
			setTimeout(function () { selectedPiece = null; }, 300);
			
			if (event.ctrlKey) {
				piecesToDraw[i].levelData.cx = piecesToDraw[i].levelData.fx;
				piecesToDraw[i].levelData.cy = piecesToDraw[i].levelData.fy;
				piecesToDraw[i].levelData.inPlace = true;
				var temp = piecesToDraw[i];
				piecesToDraw.splice(i, 1);			// move piece
				piecesToDraw.unshift(temp);			//  to bottom
				if (checkLevelDone()) {
					zoomOut();
				}
			} else {
				draggingPiece = piecesToDraw[i];
				piecesToDraw.splice(i, 1);			// move touched piece
				piecesToDraw.push(draggingPiece);	//  to top
				draggingPiece.levelData.inPlace = false;
				draggingPiece.levelData.cx = mouseX;
				draggingPiece.levelData.cy = mouseY;
			}
			redraw();
			event.preventDefault();
			break;
		}
	}
}

canvas.onmousemove = function (e) {
	if (draggingPiece != null) {
		var mouseX = e.clientX - canvas.width/2;
		var mouseY = e.clientY - canvas.height/2;
		draggingPiece.levelData.cx = mouseX;
		draggingPiece.levelData.cy = mouseY;
		redraw();
		event.preventDefault();
	}
}

canvas.onmouseup = function (e) {
	if (draggingPiece != null) {
		var mouseX = e.clientX - canvas.width/2;
		var mouseY = e.clientY - canvas.height/2;
		draggingPiece.levelData.cx = mouseX;
		draggingPiece.levelData.cy = mouseY;
		if (Math.abs(draggingPiece.levelData.fx - mouseX) < 13 &&
			Math.abs(draggingPiece.levelData.fy - mouseY) < 13) {
				draggingPiece.levelData.cx = draggingPiece.levelData.fx;
				draggingPiece.levelData.cy = draggingPiece.levelData.fy;
				piecesToDraw.pop();							// move piece
				piecesToDraw.unshift(draggingPiece);		//  to bottom
				draggingPiece.levelData.inPlace = true;
		}
		redraw();
		draggingPiece = null;
		event.preventDefault();
		if (checkLevelDone()) {
			zoomOut();
		}
	}
}

$scope.zoomInClick = function() {
	$scope.path.push($scope.ii);
	currentLevel = levelPath($scope.path);
	if (currentLevel != null) {
		blah();
	} else {
		alert('Could not find');;;
	}
}

$scope.zoomOutClick = zoomOut;

function checkLevelDone() {
	for (var i=1; i<piecesToDraw.length; ++i) {
		if (!piecesToDraw[i].levelData.inPlace) {
			return false;
		}
	}
	return true;
}

function levelPath(path) {
	var level = levelData;
	for (var i=0; i<path.length; ++i) {
		level = level.children[path[i]];
	}
	return level;
}

function blah(level) {
	var children = currentLevel.children || [];
	var bigPiece = new Piece(4);
	bigPiece.xorRect(0, 0, bigPiece.wholeSide, bigPiece.wholeSide, 255, 255, 200, 0);
	bigPiece.makePiece(currentLevel.u0, currentLevel.v0, currentLevel.du, currentLevel.dv);
	bigPiece.outline();
	bigPiece.toImg();
	bigPiece.levelData = {cx: 0, cy: 0};
	backgroundPieces[0] = bigPiece;
	piecesToDraw = [];

	for (var i=0; i<children.length; ++i) {
		var c = children[i];
		if (c == null) {
			continue;
		}
		var piece = new Piece(3);
		piece.levelData = c;
		var color = c.children ? 210 : 100;
		piece.xorRect(0, 0, piece.wholeSide, piece.wholeSide, 255, color, color, 0);
		piece.makePiece(c.u0, c.v0, c.du, c.dv);
		piece.inoutline();
		piece.toImg();
		piecesToDraw.push(piece);
	}
	redraw();
	
	var piecesForWorker = [];
	for (var i=0; i<piecesToDraw.length; ++i) {
		piecesToDraw[i].rendered = false;
		if (piecesToDraw[i].levelData.needsRendering) {
			piecesToDraw[i].randomizer = Math.random();
			if (piecesToDraw[i].levelData == level) {
				console.log('priority!');;;
				piecesToDraw[i].randomizer = -1;
			}
			piecesForWorker.push(piecesToDraw[i]);
		}
	}
	piecesForWorker.sort(function (a, b) { return a.randomizer - b.randomizer; });
	console.log(piecesForWorker);;;
	var iout = 0;
	if (iout < piecesForWorker.length) {
		piece = piecesForWorker[iout];
		var ld = piece.levelData;
		var re = ld.re0 - ld.dre / piece.pieceSide * piece.padding;
		var im = ld.im0 - ld.dim / piece.pieceSide * piece.padding;
		var dre = ld.dre / piece.pieceSide * piece.wholeSide;
		var dim = ld.dim / piece.pieceSide * piece.wholeSide;
		worker.postMessage({path: ld.path, re: re, im: im, dre: dre, dim: dim, w: piece.wholeSide, h: piece.wholeSide, data: piece.imageData.data});
	}

	var iin = 0;
	worker.onmessage = function (event) {
		if (JSON.stringify(piecesForWorker[iin].levelData.path) == JSON.stringify(event.data.path)) {	// hack!
			piecesForWorker[iin].imageData = new ImageData(event.data.data, piecesForWorker[iin].wholeSide, piecesForWorker[iin].wholeSide);
			piecesForWorker[iin].toImg();
			piecesForWorker[iin].rendered = true;
			++iin;
		}
		++iout;
		if (iout < piecesForWorker.length) {
			piece = piecesForWorker[iout];
			var ld = piece.levelData;
			var re = ld.re0 - ld.dre / piece.pieceSide * piece.padding;
			var im = ld.im0 - ld.dim / piece.pieceSide * piece.padding;
			var dre = ld.dre / piece.pieceSide * piece.wholeSide;
			var dim = ld.dim / piece.pieceSide * piece.wholeSide;
			worker.postMessage({path: ld.path, re: re, im: im, dre: dre, dim: dim, w: piece.wholeSide, h: piece.wholeSide, data: piece.imageData.data});
		}
		redraw();
	};
}



function resize() {
	var div = document.getElementById('drawdiv');
	canvas.width = div.clientWidth;
	canvas.height = div.clientHeight;
	redraw();
}

var redrawing = false;

function redraw() {
	if (!redrawing) {
		requestAnimationFrame(_redraw);
		redrawing = true;
	}
}

var displayMode = 'normal';
var altPiecesToDraw = [];

var zoomOutState = 0;
var zoomOutStartTime;

function zoomOut() {
	if ($scope.path.length > 0) {
		currentLevel.needsRendering = checkLevelDone();
		displayMode = 'zoomout';
		zoomOutState = 0;
	}
}

var altScale, altX, altY, altLevel;

function _redraw(ms) {
	redrawing = false;
	if (displayMode == 'zoomout') {
		var destX = currentLevel.cx;
		var destY = currentLevel.cy;
		switch (zoomOutState) {
			case 0:
				zoomOutStartTime = ms;
				zoomOutState = 1;
				altLevel = currentLevel;
				break;
			case 1:
				var t = ms - zoomOutStartTime;
				if (t > 500) {
					zoomOutState = 2;
					altPiecesToDraw = piecesToDraw;
					piecesToDraw = [];
					backgroundPieces = [null, null];
				}
				break;
			case 2:
				var t = ms - zoomOutStartTime - 500;
				if (t > 1500) {
					t = 1500;
					zoomOutState = 3;
				}
				var s = t / 1500;			// 0..1
				altScale = 1 - s * 0.8;		// 1..0.2
				altX = destX * s;
				altY = destY * s;
				break;
			case 3:
				altScale = 0.2;
				altX = destX;
				altY = destY;
				$scope.path.pop();
				currentLevel = levelPath($scope.path);
				blah(altLevel);
				zoomOutState = 4;
				break;
			case 4:
				for (var i=0; i<piecesToDraw.length; ++i) {
					if (piecesToDraw[i].levelData == altLevel && piecesToDraw[i].rendered) {
						altPiecesToDraw = [];
						displayMode = 'normal';
						console.log('done');;;
					}
				}
				break;
		}
		redraw();
	}

	ctx.fillStyle = 'teal';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.save();
	ctx.translate(canvas.width/2, canvas.height/2);
	for (var i=0; i<2; ++i) {
		if (backgroundPieces[i] != null) {
			backgroundPieces[i].draw(ctx);
		}
	}

	for (var i=0; i<piecesToDraw.length; ++i) {
		piecesToDraw[i].draw(ctx);
	}

	ctx.translate(altX, altY);
	ctx.scale(altScale, altScale);
	for (var i=0; i<altPiecesToDraw.length; ++i) {
		altPiecesToDraw[i].draw(ctx);
	}

	ctx.restore();
	
}

function resizeListener(e) {
	resize();
}

function createData(re, im, zoom, levels) {
	var re0 = re - 2/zoom;
	var im0 = im + 2/zoom;
	var dre = 4 / zoom;
	var dim = -4 / zoom;
	return createDataHelper([], re0, im0, dre, dim, 100, 230, 625, 625, 0, 0, 0, 0, 0, levels);
	
	function createDataHelper(path, re0, im0, dre, dim, u0, v0, du, dv, cx, cy, fx, fy, rot, levels) {
		var levelData = {
			path: path.slice(),	// *copy* of path
			re0: re0,
			im0: im0,
			dre: dre,
			dim: dim,
			u0: u0,
			v0: v0,
			du: du,
			dv: dv,
			cx: cx,		// current position
			cy: cy,
			fx: fx,		// final position
			fy: fy,
			rot: rot,
			inPlace: false
		};
		
		if (levels == 0) {
			levelData.needsRendering = true;
			levelData.children = null;
		} else {
			levelData.needsRendering = false;
			levelData.children = [];

			var piece = new Piece(1);
			piece.makePiece(u0, v0, du, dv);

			dre /= 5;
			dim /= 5;
			du /= 5;
			dv /= 5;
			for (var i=-1; i<=5; ++i) {
				var v = v0 + i * dv;
				var im = im0 + i * dim;
				fy = (i - 2) * 125;
				for (var j=-1; j<=5; ++j) {
					var u = u0 + j * dv;
					var re = re0 + j * dre;
					fx = (j - 2) * 125;
					cx = (Math.random() - 0.5) * 7 * 125;
					cy = (Math.random() - 0.5) * 7 * 125;
					if (piece.get(piece.padding+j, piece.padding+i).a) {
						path.push(levelData.children.length);
						levelData.children.push(createDataHelper(path, re, im, dre, dim, u, v, du, dv, cx, cy, fx, fy, rot, levels-1));
						path.pop();
					} else {
						levelData.children.push(null);
					}
				}
			}
		}
		return levelData;
	}
}
});
	</script>
</body>
</html>
